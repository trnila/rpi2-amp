#include "FreeRTOS.h"

#define portNO_CRITICAL_NESTING		( ( unsigned long ) 0 )
// TODO: not used currently
// each task restores value from own stack to this global variable
volatile unsigned long ulCriticalNesting = 9999UL;


// ISR to handle manual context switches (from a call to taskYIELD())
void vPortYieldProcessor( void ) __attribute__((interrupt("SWI"), naked));
void vPortISRStartFirstTask( void );

void vPortISRStartFirstTask( void )
{
	portENABLE_INTERRUPTS();
	portRESTORE_CONTEXT();
	panic("unreachable code\n");
}

/*
 * Called by portYIELD() or taskYIELD() to manually force a context switch.
 *
 * When a context switch is performed from the task level the saved task 
 * context is made to look as if it occurred from within the tick ISR.  This
 * way the same restore context function can be used when restoring the context
 * saved from the ISR or that saved from a call to vPortYieldProcessor.
 */
void vPortYieldProcessor( void )
{
	// Perform the context switch.  First save the context of the current task.
	portSAVE_CONTEXT();

	// Find the highest priority task that is ready to run.
	__asm volatile ( "bl vTaskSwitchContext" );

	// Restore the context of the new task.
	portRESTORE_CONTEXT();	
}

/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
void vPortEnterCritical( void )
{
	// TODO: not implemented yet
//	portDISABLE_INTERRUPTS();
	/* Now interrupts are disabled ulCriticalNesting can be accessed 
	directly.  Increment ulCriticalNesting to keep a count of how many times
	portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
}

void vPortExitCritical( void )
{
	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
	{
		// Decrement the nesting count as we are leaving a critical section.
		ulCriticalNesting--;

		// If the nesting level has reached zero then interrupts should be re-enabled
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
		{
			//TODO: enable interrupts
			portENABLE_INTERRUPTS();
			// Enable interrupts as per portEXIT_CRITICAL()
		}
	}
}
